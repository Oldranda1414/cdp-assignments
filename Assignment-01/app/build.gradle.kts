/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.6/userguide/building_java_projects.html in the Gradle documentation.
 */

import org.gradle.configurationcache.extensions.capitalized
import java.io.ByteArrayOutputStream
import java.io.OutputStream

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    application

    id("java") //ADDED FOR JPF
}

group = "org.example"
version = "1.0-SNAPSHOT"

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation(libs.junit.jupiter)

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation(libs.guava)
    implementation(files("lib/jpf-classes.jar"))
    implementation(files("lib/jpf-annotations.jar"))
}

tasks.getByName<Test>("test") {
    useJUnitPlatform()
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
        vendor.set(JvmVendorSpec.ADOPTIUM)
    }
}

// Utility function for verification through JPF

val verificationGroup = "Verification"

val verifyAll by tasks.register<DefaultTask>("runVerifyAll") {
    group = verificationGroup
    description = "Run all the JPF verification"
}

/**
 * This function will return an array of string that will be used to mount the container
 * The container will be mounted with all the files and folders of the project, except the build folder
 */
val allFileButBuildAndHide = File(rootProject.rootDir.path)
    .listFiles { a -> !(a.name.startsWith(".") || a.name == "build") }
    .map { it -> "type=bind,source=${it.absolutePath},target=/home/${it.name}" }
    .flatMap { it ->  listOf("--mount", it) }
    .toTypedArray()

// Path in which the search of other jpf file starts
val searchingPath = "/src/main/jpf/"

// Output for all tasks
val noOutput = ByteArrayOutputStream()

application {
    // Define the main class for the application.
    mainClass.set("pcd.ass01.simtrafficexamplesconcurrent.part2.RunTrafficSimulation")
}

/**
 * This will create a task for each jpf file in the src/main/jpf folder
 * Particularly, it will create two tasks called run<FileName>Verify and run<FileName>Clean
 * The first one will run the verification, the second one will clean the container
 * With cleanAll you can clean all the containers, you can do that when you want clean the environment
 * If you have a jpf in another path, then it is better to use the jpfVerify task
 */
File(rootProject.rootDir.path + "/app" + searchingPath).listFiles()
    ?.filter { it.extension == "jpf" }
    ?.sortedBy { it.nameWithoutExtension }
    ?.forEach {
        fun launchVerificationTask(taskName: String, file: File) = tasks.register<JavaExec>(taskName) {
            group = verificationGroup
            description = "Verify the ${file.nameWithoutExtension} using JPF"
            javaLauncher.set(
                javaToolchains.launcherFor {
                    languageVersion.set(JavaLanguageVersion.of(8))
                }
            )
            main = "-jar"
            args = listOf("./jpf-runner/build/RunJPF.jar", ".${searchingPath}" + file.name)
        }
        val capitalizedName = it.nameWithoutExtension.capitalize()
        val jpfVerification by launchVerificationTask("run${capitalizedName}Verify", it)
        jpfVerification.dependsOn(tasks.getByName("compileJava"))
        verifyAll.dependsOn(jpfVerification)
    }